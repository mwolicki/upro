// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Ast$Uprolog = require("./Ast.bs.js");
var Lexer$Uprolog = require("./lexer.bs.js");
var Parser$Uprolog = require("./parser.bs.js");

function print_position(lexbuf) {
  var pos = lexbuf[/* lex_curr_p */11];
  return Curry._3(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */Block.__(12, [
                          /* ":" */58,
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* Char_literal */Block.__(12, [
                                  /* ":" */58,
                                  /* Int */Block.__(4, [
                                      /* Int_d */0,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "%s:%d:%d"
                ]), pos[/* pos_fname */0], pos[/* pos_lnum */1], (pos[/* pos_cnum */3] - pos[/* pos_bol */2] | 0) + 1 | 0);
}

function text(code) {
  var lexbuf = Lexing.from_string(code);
  var init = lexbuf[/* lex_curr_p */11];
  lexbuf[/* lex_curr_p */11] = /* record */[
    /* pos_fname */init[/* pos_fname */0],
    /* pos_lnum */0,
    /* pos_bol */0,
    /* pos_cnum */init[/* pos_cnum */3]
  ];
  try {
    return /* `Ok */[
            17724,
            Ast$Uprolog.$$eval(Parser$Uprolog.parse(Lexer$Uprolog.read, lexbuf))
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Lexer$Uprolog.$$SyntaxError) {
      var x = Curry._2(Printf.sprintf(/* Format */[
                /* String_literal */Block.__(11, [
                    "pos ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            ": ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ])
                      ])
                  ]),
                "pos %s: %s"
              ]), print_position(lexbuf), exn[1]);
      return /* `Err */[
              3456837,
              x
            ];
    } else if (exn === Parser$Uprolog.$$Error) {
      var x$1 = Curry._1(Printf.sprintf(/* Format */[
                /* String_literal */Block.__(11, [
                    "pos ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            ": parser error",
                            /* End_of_format */0
                          ])
                      ])
                  ]),
                "pos %s: parser error"
              ]), print_position(lexbuf));
      return /* `Err */[
              3456837,
              x$1
            ];
    } else {
      throw exn;
    }
  }
}

exports.print_position = print_position;
exports.text = text;
/* No side effect */
